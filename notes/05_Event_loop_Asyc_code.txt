6. EVENT LOOP

1.Event Driven
2.Single Threaded
3.V8 vs Libuv
4.node Runtime
5.Event Loop
6.Async code 
7.Blocking code

6.1 Event Driven
	On. data
	On. End 
	user-> click ->Event Listener -> Event Queue -> Event Loop -> Event handler

6.2 single Threaded
	
	Request,event -> Event Loop (single work data) -> Thread Pool (WorkerThread(maindata))
	
	Main work : Event Loop karse 
	File System,database file -> WorkerThread karse
	opration completed thay pachu event loop jay 
	pachi event loop trigger callback : req jay

6.3 V8 Vs Libuv
	V8:
	1. open-source Javascipt engine by google.
	2. Used in Chrome and node.js
	3. comiles Javascript To native Machine code.
	4. Ensure high-performance Javascript Execution.

	libuv:
	1. multi-platform support library for node.js
	2. Handles asnchronous i/o operation.
	3. Provide Event-driven architecture.
	4. manegs file-system,networking and timers non-blocking across platforms.

6.4 Node Runtime 

	An invoked funtion in added to the call stack. once it return a value, it 	is popped off.
	
6.5 Event Loop
	timers: this phase executes callbacks scheduled by setTimeout() and 
		setInterval().
	● pending callbacks: executes I/O callbacks 
		deferred to the next loop iteration.
	● idle, prepare: only used internally.
	● poll: retrieve new I/O events; execute I/O related callbacks (almost all 		with the exception of close callbacks, the ones scheduled by 
		timers, and setImmediate()); node will block here when 		appropriate.
	● check: setImmediate() callbacks are invoked here.
	● close callbacks: some close callbacks, e.g. 
		socket.on('close', ...).

6.6 Async Code

	const sumRequest = (req, res) => {
    console.log("1. In Sum request handles", req.url);
    const body = [];
    let result;
    req.on('data', chunk => {
        body.push(chunk);
        console.log("2. chunk Came");
    })
    req.on('end', () => {
         console.log("3. End Event came");
        const bodyStr = Buffer.concat(body).toString();
        console.log(bodyStr)
        const params = new URLSearchParams(bodyStr);
        const bodyobj = Object.fromEntries(params);
        console.log(bodyobj)
        result = parseInt(bodyobj.first) + parseInt(bodyobj.second);
        console.log(result);
       
    });
 console.log("4. Sending response");
     res.setHeader('Content-Type', 'text/html');
        res.write(
            `<html>
                <head>
                    <title>Calcultor</title>
                </head>
                <body>
                    <h1>Your Sum Is ${result}</h1>
                </body>
            </html>
            `
        );
        return res.end();
}

exports.sumRequest = sumRequest;

6.7 Blocking Code

	user.js :	
	Code :  this code change to Block line
	 const bodyObject = Object.fromEntries(params);
            console.log(bodyObject);
            fs.writeFileSync('user.txt',JSON.stringify			(bodyObject));

	change code : 
	  fs.writeFile('user.txt', JSON.stringify		(bodyObject), error => {
                console.log('Data Written Successfully');
                res.statusCode = 302;
                res.setHeader('Location', '/');
                return res.end();
            });


Excess : 
	Run & Observe
		
	
	Blocking vs Async

	const fs = require('fs');
	console.log('1. Start of script' );
	// Synchronous (blocking) operation
	console.log('2. Reading file synchronously' );
	const dataSync = fs.readFileSync ('user-details.txt' , 'utf8');
	console.log('3. Synchronous read complete' );
	// Asynchronous (non-blocking) operation
	console.log('4. Reading file asynchronously' );
	fs.readFile('user-details.txt' , 'utf8', (err, dataAsync ) => {
	if (err) throw err;
	console.log('6. Asynchronous read complete' );
	});
	console.log('5. End of script' );
	